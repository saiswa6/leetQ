/*
Approach #2: Sliding Window [Accepted]
Intuition
- For each right, call opt(right) the smallest left so that the product of the subarray nums[left] * nums[left + 1] * ... * nums[right] is less than k. opt is a monotone increasing function, so we can use a sliding window.

Algorithm
- Our loop invariant is that left is the smallest value so that the product in the window prod = nums[left] * nums[left + 1] * ... * nums[right] is less than k.
- For every right, we update left and prod to maintain this invariant. Then, the number of intervals with subarray product less than k and with right-most coordinate right, is right - left + 1. We'll count all of these for each value of right.

Complexity Analysis
Time Complexity: O(N), where NNN is the length of nums. left can only be incremented at most N times.

Space Complexity: O(1), the space used by prod, left, and ans.
*/

class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k <= 1) {
            return 0;
        }
        int prod = 1, ans = 0, left = 0;
        for (int right = 0; right < nums.length; right++) {
            prod *= nums[right];
            while (prod >= k) {
                prod /= nums[left++];
            }
            ans += right - left + 1;
        }
        return ans;
    }
}


/*
ans += right - left + 1....  How ?

For those who are confused, let's use the example nums = [10,5,2,6]:

 - If we start at the 0th index, [10,5,2,6], the number of intervals is obviously 1.
 - If we move to the 1st index, the window is now [10,5,2,6]. The new intervals created are [5] and [10,5], so we add 2.
 - Now, expand the window to the 2nd index: [10,5,2,6]. The new intervals are [2], [5,2], and [10,5,2], so we add 2.
 - The pattern should be obvious by now; we add right - left + 1 to the output variable every loop!

-  For every new right, after updating left, all of [left, right], [left + 1, right], ..., [right, right] are valid subarrays whose product is less than k. How many are there? There are exactly right - left + 1.

- In short, "right - left + 1" gives the number of new sub-arrays generated upon adding a new element in the array.
Lets assume that K =10

Suppose a = {2, 1, 2}
On adding "1" to a
makes a = {2, 1, 2, 1}

So the new sub-arrays generated by addition of one element are :
.........{1}
......{2,1}
...{1,2,1}
{2,1,2,1}

So the number of newly created sub-array are 4.
And which can be visualized by taking elements one by one from right to left and making a new sub-array.
So with this intuition, we can say that the number of new sub-arrays which gets generated on addition of element are equal to the number of elements in the array.

{2, 1, 2, 1}
.^...........^
Left.....Right
(1)........(4) <= Position of Pointers if array index starts with 1
or
(0)........(3) <= Position of Pointers if array index starts with 0

Number of elements = Number of newly generated Sub-arrays = (Right - Left + 1)
= (4) - (1) + 1 = 4
.............or
= (3) - (0) + 1 = 4

Each time an element is added to the array few new sub-arrays are generated, which are counted by the number of elements in the new array & then storing the value in the count variable.
*/
